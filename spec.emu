<!DOCTYPE html>
<meta charset="UTF-8" />
<link rel="stylesheet" href="./ecmarkup.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css" />
<script src="./ecmarkup.js"></script>
<pre class="metadata">
    title: REPL Parse Goal and Environment Record for JS
    stage: -1
    contributors: ExE Boss
</pre>

<emu-clause id="sec-executable-code-and-execution-contexts">
	<h1>Executable Code and Execution Contexts</h1>

	<emu-clause id="sec-environment-records">
		<h1>Environment Records</h1>
		<emu-clause id="sec-the-environment-record-type-hierarchy">
			<h1>The Environment Record Type Hierarchy</h1>
			<ul>
				<li>
					<p>Environment Record (abstract)</p>
					<ul>
						<li>
							<p>A <em><emu-xref href="#sec-declarative-environment-records">declarative Environment Record</emu-xref></em> is used to define the effect of ECMAScript language syntactic elements such as |FunctionDeclaration|s, |VariableDeclaration|s, and |Catch| clauses that directly associate identifier bindings with ECMAScript language values.</p>
							<ul>
								<li>
									<p><ins>A <em>REPL Environment Record</em> contains the bindings for the top-level declarations of a |REPLInput|. It also contains the bindings that are explicitly imported by the |REPLInput|. Its [[OuterEnv]] is a <emu-xref href="#sec-global-environment-records">global Environment Record</emu-xref>.</ins></p>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>

			<emu-clause id="sec-repl-environment-records">
				<h1>REPL Environment Records</h1>
				<p>A <dfn>REPL Environment Record</dfn> is a <emu-xref href="#sec-declarative-environment-records">declarative Environment Record</emu-xref> that is used to represent the top-level scope of a |REPLInput|.</p>
				<p>Due to the intended use case of REPL Environment Records being REPL invocations, all top-level bindings are mutable and deletable.</p>

				<emu-clause id="sec-repl-environment-records-createmutablebinding-n-d">
					<h1>CreateMutableBinding ( _N_, _D_ )</h1>
					<p>The concrete Environment Record method CreateMutableBinding for REPL Environment Records creates a new mutable binding for the name _N_ that is uninitialized if it doesn't already exist.</p>
					<emu-alg>
						1. Let _envRec_ be the REPL Environment Record for which the method was invoked.
						1. If _envRec_ does not already have a binding for _N_, then
							1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized and that it may be deleted by a subsequent DeleteBinding call.
						1. Return NormalCompletion(~empty~).
					</emu-alg>
				</emu-clause>

				<emu-clause id="sec-repl-environment-records-createimmutablebinding-n-s">
					<h1>CreateImmutableBinding ( _N_, _S_ )</h1>
					<p>The concrete Environment Record method CreateImmutableBinding for REPL Environment Records creates a new mutable binding for the name _N_ that is uninitialized if it doesn't already exist. If the Boolean argument _S_ has the value *true* the new binding is marked as a strict binding.</p>
					<emu-alg>
						1. Let _envRec_ be the REPL Environment Record for which the method was invoked.
						1. If _envRec_ does not already have a binding for _N_, then
							1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized and that it may be deleted by a subsequent DeleteBinding call. If _S_ is *true*, record that the newly created binding is a strict binding.
						1. Return NormalCompletion(~empty~).
					</emu-alg>
				</emu-clause>


				<emu-clause id="sec-repl-environment-records-initializebinding-n-v">
					<h1>InitializeBinding ( _N_, _V_ )</h1>
					<p>The concrete Environment Record method InitializeBinding for REPL Environment Records is used to set the bound value of the current binding of the identifier whose name is the value of the argument _N_ to the value of argument _V_. A binding for _N_ must already exist.</p>
					<emu-alg>
						1. Let _envRec_ be the REPL Environment Record for which the method was invoked.
						1. Assert: _envRec_ must have a binding for _N_.
						1. Set the bound value for _N_ in _envRec_ to _V_.
						1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.
						1. Return NormalCompletion(~empty~).
					</emu-alg>
				</emu-clause>
			</emu-clause>
		</emu-clause>
	</emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
	<h1>ECMAScript Language: Scripts and Modules</h1>
	<emu-clause id="sec-scripts">
		<h1>Scripts</h1>
		<h2>Syntax</h2>
		<emu-grammar type="definition">
			Script[?Await] :
				ScriptBody[?Await]?

			ScriptBody[?Await] :
				StatementList[~Yield, ?Await, ~Return]
		</emu-grammar>
	</emu-clause>

	<emu-clause id="sec-repl-input">
		<h1>REPL Input</h1>
		<h2>Syntax</h2>
		<emu-grammar type="definition">
			REPLInput :
				Script[+Await]
		</emu-grammar>

		<emu-clause id="sec-repl-input-records">
			<h1>REPL Input Records</h1>
			<p>A <dfn>REPL Input Record</dfn> encapsulates information about a REPL input being evaluated. Each REPL Input Record contains the fields listed in <emu-xref href="#table-repl-input-records"></emu-xref>.</p>

			<emu-table id="table-repl-input-records" caption="REPL Input Record Fields">
				<table>
					<thead>
						<tr>
							<th>
								Field Name
							</th>
							<th>
								Value Type
							</th>
							<th>
								Meaning
							</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								[[Realm]]
							</td>
							<td>
								Realm Record | *undefined*
							</td>
							<td>
								The realm within which this REPL input was created. *undefined* if not yet assigned.
							</td>
						</tr>
						<tr>
							<td>
								[[Environment]]
							</td>
							<td>
								REPL Environment Record | *undefined*
							</td>
							<td>
								The REPL Environment Record containing the top level bindings for this REPL input. This field is set when the REPL input is instantiated.
							</td>
						</tr>
						<tr>
							<td>
								[[ECMAScriptCode]]
							</td>
							<td>
								a Parse Node
							</td>
							<td>
								The result of parsing the source text of this REPL input using |REPLInput| as the goal symbol.
							</td>
						</tr>
						<tr>
							<td>
								[[HasTopLevelAwait]]
							</td>
							<td>
								*true* | *false*
							</td>
							<td>
								Whether this REPL input contains a top-level await. This field must not change after the REPL input is parsed.
							</td>
						</tr>
						<tr>
							<td>
								[[HostDefined]]
							</td>
							<td>
								Any, default value is ~empty~.
							</td>
							<td>
								Field reserved for use by host environments that need to associate additional information with a REPL input.
							</td>
						</tr>
					</tbody>
				</table>
			</emu-table>
		</emu-clause>

		<emu-clause id="sec-parse-repl-input" aoid="ParseREPLInput">
			<h1>ParseREPLInput ( _sourceText_, _realm_, _hostDefined_ )</h1>
			<p>The abstract operation ParseREPLInput takes arguments _sourceText_, _realm_ (A Realm Record or *undefined*), and _hostDefined_. It creates a REPL Input Record based upon the result of parsing _sourceText_ as a |REPLInput|. It performs the following steps when called:</p>

			<emu-alg>
				1. Assert: _sourceText_ is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>).
				1. Parse _sourceText_ using |REPLInput| as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let _body_ be the resulting parse tree. Otherwise, let _body_ be a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-defined manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.
				1. If _body_ is a List of errors, return _body_.
				1. Let _hasTopLevelAwait_ be _body_ Contains `await`.
				1. Return REPL Input Record { [[Realm]]: _realm_, [[Environment]]: *undefined*, [[ECMAScriptCode]]: _body_, [[HasTopLevelAwait]]: _hasTopLevelAwait_, [[HostDefined]]: _hostDefined_ }.
			</emu-alg>
		</emu-clause>

		<emu-clause id="sec-repl-input-evaluation">
			<h1>REPLInputEvaluation ( _replInputRecord_ )</h1>
			<p>The abstract operation REPLInputEvaluation takes argument _replInputRecord_ (A REPL Input Record). It performs the following steps when called:</p>

			<emu-alg>
				1. Let _replEnv_ be _replInputRecord_.[[Environment]].
				1. Assert: _replEnv_ is a REPL Environment Record.
				1. Let _replInputContext_ be a new ECMAScript code execution context.
				1. Set the Function of _replInputContext_ to *null*.
				1. Set the Realm of _replInputContext_ to _replInputRecord_.[[Realm]].
				1. Set the ScriptOrModule of _replInputContext_ to _replInputRecord_.
				1. Set the VariableEnvironment of _replInputContext_ to _replEnv_.
				1. Set the LexicalEnvironment of _replInputContext_ to _replEnv_.
				1. Suspend the currently running execution context.
				1. Push _replInputContext_ onto the execution context stack; _replInputContext_ is now the running execution context.
				1. Let _replInputBody_ be _replInputRecord_.[[ECMAScriptCode]].
				1. Perform ! BlockDeclarationInstantiation(_replInputBody_, _replEnv_).
				1. If _replInputRecord_.[[HasTopLevelAwait]] is *true*, then
					1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
					1. Let _asyncContext_ be a copy of _replInputContext_.
					1. Perform ! AsyncBlockStart(_promiseCapability_, _replInputBody_, _asyncContext_).
					1. Suspend _replInputContext_ and remove it from the execution context stack.
					1. Assert: The execution context stack is not empty.
					1. Resume the context that is now on the top of the execution context stack as the running execution context.
					1. Return _promiseCapability_.
				1. Else,
					1. Let _result_ be the result of evaluating _replInputBody_.
					1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
						1. Set _result_ to NormalCompletion(*undefined*).
					1. Suspend _replInputContext_ and remove it from the execution context stack.
					1. Assert: The execution context stack is not empty.
					1. Resume the context that is now on the top of the execution context stack as the running execution context.
					1. Return Completion(_result_).
			</emu-alg>
		</emu-clause>
	</emu-clause>
</emu-clause>

<emu-clause id="sec-asyncblockstart" aoid="AsyncBlockStart">
	<h1>AsyncBlockStart ( _promiseCapability_, _asyncBody_, _asyncContext_ )</h1>
	<emu-alg>
		1. Assert: _promiseCapability_ is a PromiseCapability Record.
		1. Let _runningContext_ be the running execution context.
		1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
			1. Let _result_ be the result of evaluating _asyncBody_.
			1. Assert: If we return here, the async block either threw an exception or performed an implicit or explicit return; all awaiting is done.
			1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
			1. If _result_.[[Type]] is ~normal~, then
				1. <ins>If _asyncBody_ is a |REPLInput|, then</ins>
					1. <ins>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_.[[Value]] &raquo;).</ins>
				1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
			1. Else if _result_.[[Type]] is ~return~, then
				1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
			1. Else,
				1. Assert: _result_.[[Type]] is ~throw~.
				1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
			1. [id="step-asyncfunctionstart-return-undefined"] Return.
		1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
		1. Resume the suspended evaluation of _asyncContext_. Let _result_ be the value returned by the resumed computation.
		1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
		1. Assert: _result_ is a normal completion with a value of *undefined*. The possible sources of completion values are Await or, if the async block doesn't await anything, the step <emu-xref href="#step-asyncfunctionstart-return-undefined"></emu-xref> above.
	</emu-alg>
</emu-clause>
